# how to modernize legacy applications with github copilot (a moonshot demo) ğŸŒš

## whoami

- ğŸ‘©â€ğŸ’» **julia kordick** (she/her)
- ğŸ’¼ global black belt - developer productivity @ microsoft
- ğŸ› ï¸ focus: devops, platform engineering, github, developer experience & velocity, sdlc
- ğŸ“ tl;dr: end-to-end software engineering that is safe, sane & consensual
- ğŸ“ studied computer science
- ğŸ‘©â€ğŸ« 8 yrs as software engineer & dev lead
- ğŸ¢ 3 yrs at microsoft
- ğŸš´â€â™€ï¸ & ğŸ‹ï¸â€â™€ï¸ fahrrad & gym maus

## what are we doing here?
- talk about legacy apps & modernization
- chances & challenges of using AI in this context

## why is legacy modernization hard 
- lost institutional knowledge
- lack of documentation
- lack of tests
- poor code quality

### especially COBOL
- experts are dying (literally)
- complexity (and length) of the code itself and the call-chain
- non-english code

## Demo of GitHub Copilot
- completion
- ask
- agent
- context
- instructions
- models
- extensions

## app modernization, how could smart steps look like?
- reverse engineering
- prepare code for AI
 - comment 
 - translate?
- flow analysis and visualization
- test generation (TDD?)
- use dependencies
- use cobol code only as backup, rely on generated documentation for generation instead

## let's do this!

## qs and considerations
- as this is a very simple project this is obviously not a real world example
- why did I choose it? when it is possible with something like COBOL, and LLMs have very limited context, it is possible with other languages as well (and probably better)
- real world COBOL code is much more complex and brings GitHub Copilot and in general single agents to their limits
- but it is indeed a useful tool to get started with the preparation and reverser engineering of the code

