# how to modernize legacy applications with github copilot (a moonshot demo) 🌚

## whoami

- 👩‍💻 **julia kordick** (she/her)
- 💼 global black belt - developer productivity @ microsoft
- 🛠️ focus: devops, platform engineering, github, developer experience & velocity, sdlc
- 📝 tl;dr: end-to-end software engineering that is safe, sane & consensual
- 🎓 studied computer science
- 👩‍🏫 8 yrs as software engineer & dev lead
- 🏢 3 yrs at microsoft
- 🚴‍♀️ & 🏋️‍♀️ fahrrad & gym maus

## what are we doing here?
- talk about legacy apps & modernization
- chances & challenges of using AI in this context

## why is legacy modernization hard 
- lost institutional knowledge
- lack of documentation
- lack of tests
- poor code quality

### especially COBOL
- experts are dying (literally)
- complexity (and length) of the code itself and the call-chain
- non-english code

## Demo of GitHub Copilot
- completion
- ask
- agent
- context
- instructions
- models
- extensions

## app modernization, how could smart steps look like?
- reverse engineering
- prepare code for AI
 - comment 
 - translate?
- flow analysis and visualization
- test generation (TDD?)
- use dependencies
- use cobol code only as backup, rely on generated documentation for generation instead

## let's do this!

## qs and considerations
- as this is a very simple project this is obviously not a real world example
- why did I choose it? when it is possible with something like COBOL, and LLMs have very limited context, it is possible with other languages as well (and probably better)
- real world COBOL code is much more complex and brings GitHub Copilot and in general single agents to their limits
- but it is indeed a useful tool to get started with the preparation and reverser engineering of the code

